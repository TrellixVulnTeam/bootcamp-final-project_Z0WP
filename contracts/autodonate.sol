/// SPDX-License-Identifier: MIT
pragma solidity >=0.4.22 <0.9.0;

/// @title Automate the donation of a portion of the yields generated by your aTokens
/// @author @trx314
/// @notice Deposit your aTokens (yield generating Aave tokens) and donate a portion of the yield generated
/// @dev MVP version. No Aave integration yet
/// @custom:experimental This is an experimental contract.
contract autoDonate {
  
/// @notice Store the position that the donor has deposited
struct Position {
  address recipient; // the recipient who will receive the donation
  uint percentDonate; // the share (integer from 0 to 100) of monthly revenues to be donated
  uint balance; // the quantity of token composing the position
  uint shares; // the number of shares a user has in the contract aToken pool (the contract aToken position is the sum of all users' aTokens)
}

/// @notice The total number of shares is stored for each aToken. 
/// @dev Each position of the contract in aToken is a kind of pool of all the aToken deposited by the users.
mapping (address => uint) public sharesTotal;

/// @notice whitelisted tokens allowed for deposit. Only one token (aDai) for this MVP
address public allowedToken;

/// @notice whitelisted recipients allowed for donation. Only one recipient allowed for this MVP
address public allowedRecipient;

/// @notice store the positions with the address of their owner (the DONOR) as key 1 and the address of the TOKEN deposited as key 2
// we do not put the token in the Position struct because it would require to do more looping to retrieve a given position
mapping (address => mapping (address => Position)) public positions;

/// @dev constructor initializes some values
constructor() {
  sharesTotal[0x028171bCA77440897B824Ca71D1c56caC55b68A3] = 0; // initialize the value to 0 for the allowed token used in tests
  allowedToken = 0x028171bCA77440897B824Ca71D1c56caC55b68A3; // aDai token address on mainnet
  allowedRecipient = 0x750EF1D7a0b4Ab1c97B7A623D7917CcEb5ea779C; // address on mainnet of GiveDirectly https://www.givedirectly.org/
}

/// @notice Create a balance for the user address (the donor), with the aToken transferred to the smart contract.
/// @dev TO DO: check that the token balance is suficient to create the position (get balance from Aave)
/// @dev TO DO: allow and transfer the token
/// @param token The aToken to deposit. It has to be whitelisted (allowedToken)
/// @param recipient The recipient address. It has to be whitelisted (allowedRecipient)
/// @param shareDonate The percentage of revenue generated to be donated (i.i 25 for 25%)
/// @param quantity The amount of aToken to deposit
/// @return True if the position was succesfully created
function createBalance(address token, address recipient, uint shareDonate, uint quantity) public returns (bool) {
  require(token == allowedToken); // dev: token not allowed
  require(recipient == allowedRecipient); // dev: recipient not allowed
  address donor = msg.sender;
  positions[donor][token] = Position({
    recipient: recipient,
    percentDonate: shareDonate,
    balance: quantity,
    shares: quantity // initial position=0 therefore the initial shares number is equal to the number of aTokens invested
  });
  sharesTotal[token] = sharesTotal[token] + quantity;
  return true;
}

/// @notice Get the balance of a user
/// @dev TO DO: allows to retrieve all tokens from one donor address >> will return an array instead of current
/// @param donor The address of the donor
/// @param token The address of the aToken for which we get the balance
/// @return recipient The recipient address
/// @return balance The balance
/// @return percentDonate The percentage of revenue to donate
/// @return shares The number of shares owned by the donor in the aToken contract position
function getBalance(address donor, address token) public view 
returns(address recipient, uint balance, uint percentDonate, uint shares) 
{
  recipient = positions[donor][token].recipient;
  balance = positions[donor][token].balance;
  percentDonate = positions[donor][token].percentDonate;
  shares = positions[donor][token].shares;
}

/// @notice Retrieve the balance of a given aToken by calling the getBalance Aave function. It is used either toi retrieve the balance of the autoDonate contract itself, or of a potential donor before depositing.
/// @dev TO DO: integration with Aave contract. Currently a fixed revenue is hardcoded and added to the total deposited balance. The function will therefore be "pure"
/// @param account The address of either the donor or the autoDonate smartcontract itself
/// @param token The aToken
/// @return balance The balance in aToken in Aave
function getAaveBalance(address account, address token) public view
returns(uint balance)
{
  balance = sharesTotal[token] + 12; // temporary fixed total revenue (12) for testing, waiting for aave contract integration
}

/// @notice Compute the revenue generated by an account since the last donation event
/// @dev It is computed as the difference between the share of the user of the current value of the pool and the stored user balance which represents the initial allocation.
/// @param donor The address of the donor
/// @param token The address of the aToken for which we compute the revenue generated
/// @return revenue The revenue generated by the donor's aToken position `since the last donation event
function computeRevenue(address donor, address token) public view
returns (uint revenue)
{
  uint balanceTotalPool = getAaveBalance(address(this),token); // aToken balance of the contract
  uint sharesTotalPool = sharesTotal[token]; // total number of shares for this token in the pool
  uint sharesUser = positions[donor][token].shares; // number of shares of this user
  uint balanceUser = positions[donor][token].balance; // balance of the user in t0
  revenue = balanceTotalPool * sharesUser / sharesTotalPool - balanceUser;
}

/// @notice Compute the amount to donate from a given user for a given token
/// @dev the amount is computed based on the percentDonate of the position, as a percentage of the revenue generated from this position since the last donation
/// @param donor The address of the donor
/// @param token The address of the aToken for which we compute amont to donate
/// @return toDonate The amount to donate based on the revenue generated by the donor's aToken position `since the last donation event
function computeToDonate(address donor, address token) public view
returns (uint toDonate)
{
  uint revenue = computeRevenue(donor, token);
  uint percentage = positions[donor][token].percentDonate;
  toDonate = revenue * percentage / 100;
}





// TO DO - after reviewing data structure and complement the mapping with an array to allow looping
function distributeDonations(address recipient, address token) public {
  // When called, the real balance of the token (from Aave Smart Contract) is checked against the balance stored in the smart contract (Q: does it uses gas? how will it be executed?). Because it is an aToken, the balance increases regularly

  // if the recipient position does not exist yet, create it with recipient = none
  
  // transfer the balance from the donors to the recipient

}

function withdrawal(address toWithdraw) public {
  // Withdrawals: any user including the donation addresses can withdraw at any moment *- requires being the msg.sender of the correspoonding address
}

function whitelistDonation(address toWhitelist) public {
  // adds a new address to list of addresses of donation - only contract owner can execute
  // adds a balance for the new address, with a NULL/or whatever donation address
}

function whitelistRemove(address toRemove) public {
  // removes and address from the list of addresses of donation - only contract owner can execute
}



}


